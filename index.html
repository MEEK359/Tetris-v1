<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris Game</title>
<style>
  body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #0f1724;
    color: #fff;
    font-family: Arial, sans-serif;
    position: relative;
  }
  canvas {
    background: #071022;
    border: 2px solid #0f1724;
    display: block;
  }
  .controls {
    position: absolute;
    top: 20px;
    left: 20px;
    line-height: 1.6;
  }
  .start-btn, .replay-btn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    font-size: 24px;
    border: none;
    border-radius: 12px;
    background: #007bff;
    color: #fff;
    cursor: pointer;
  }
  .mobile-controls {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
  }
  .mobile-controls button {
    padding: 20px;
    font-size: 18px;
    border: none;
    border-radius: 10px;
    background: #007bff;
    color: white;
    cursor: pointer;
  }
  .score-display {
    position: absolute;
    top: 20px;
    right: 20px;
    font-size: 20px;
  }
  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 36px;
    color: #ff0000;
    display: none;
    text-align: center;
  }
</style>
</head>
<body>
<canvas id="tetris" width="240" height="480"></canvas>
<button class="start-btn" id="startBtn">Click to Start</button>
<div class="controls">
  <p>Controls:</p>
  <p>← Move Left | → Move Right | ↑ Rotate | ↓ Soft Drop | Space Hard Drop | P Pause</p>
</div>
<div class="score-display" id="scoreDisplay">Score: 0</div>
<div class="game-over" id="gameOver">Game Over<br><button class="replay-btn" id="replayBtn">Replay</button></div>
<div class="mobile-controls">
  <button id="leftBtn">←</button>
  <button id="rightBtn">→</button>
  <button id="rotateBtn">↑</button>
  <button id="downBtn">↓</button>
  <button id="dropBtn">Space</button>
  <button id="pauseBtn">P</button>
</div>
<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const ROWS = 20;
const COLS = 10;
const BLOCK = 24;
const COLORS = [
  null,'#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'
];
const pieces = 'IJLOSTZ';

function createMatrix(width, height) {
  const matrix = [];
  while (height--) {
    matrix.push(new Array(width).fill(0));
  }
  return matrix;
}

function createPiece(type) {
  switch(type){
    case 'T': return [[0,0,0],[1,1,1],[0,1,0]];
    case 'O': return [[2,2],[2,2]];
    case 'L': return [[0,0,3],[3,3,3],[0,0,0]];
    case 'J': return [[4,0,0],[4,4,4],[0,0,0]];
    case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
    case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
    case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
  }
}

function drawMatrix(matrix, offset) {
  matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val){ ctx.fillStyle=COLORS[val]; ctx.fillRect((x+offset.x)*BLOCK,(y+offset.y)*BLOCK,BLOCK-1,BLOCK-1); }
    });
  });
}

function collide(arena,piece,pos){
  for(let y=0;y<piece.length;y++){
    for(let x=0;x<piece[y].length;x++){
      if(piece[y][x] && (arena[y+pos.y] && arena[y+pos.y][x+pos.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena,piece,pos){
  piece.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val) arena[y+pos.y][x+pos.x]=val;
    });
  });
}

function rotate(matrix,dir){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse();
}

function randomPiece(){
  const type=pieces[(pieces.length*Math.random())|0];
  return {matrix:createPiece(type),pos:{x:Math.floor(COLS/2)-1,y:0}};
}

let arena=createMatrix(COLS,ROWS), current, next;
let dropCounter=0, dropInterval=1000, lastTime=0;
let score=0, paused=false, running=false;

const scoreDisplay=document.getElementById('scoreDisplay');
const gameOverDisplay=document.getElementById('gameOver');
const startBtn=document.getElementById('startBtn');
const replayBtn=document.getElementById('replayBtn');

function draw(){
  ctx.fillStyle='#071022';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  if(current){
    drawMatrix(arena,{x:0,y:0});
    drawMatrix(current.matrix,current.pos);
  }
}

function update(time=0){
  if(!running){ lastTime=time; requestAnimationFrame(update); return; }
  if(!paused){
    const delta=time-lastTime;
    lastTime=time;
    dropCounter+=delta;
    if(dropCounter>dropInterval) drop();
    draw();
  }
  requestAnimationFrame(update);
}

function drop(){
  current.pos.y++;
  if(collide(arena,current.matrix,current.pos)){
    current.pos.y--;
    merge(arena,current.matrix,current.pos);
    sweep();
    spawn();
  }
  dropCounter=0;
}

function hardDrop(){
  while(!collide(arena,current.matrix,{x:current.pos.x,y:current.pos.y+1})) current.pos.y++;
  merge(arena,current.matrix,current.pos);
  sweep();
  spawn();
  dropCounter=0;
}

function playerMove(dir){
  current.pos.x+=dir;
  if(collide(arena,current.matrix,current.pos)) current.pos.x-=dir;
}

function playerRotate(dir){
  rotate(current.matrix,dir);
  let offset=1;
  while(collide(arena,current.matrix,current.pos)){
    current.pos.x+=offset;
    offset=-(offset+(offset>0?1:-1));
    if(offset>current.matrix[0].length){ rotate(current.matrix,-dir); return; }
  }
}

function sweep(){
  let linesCleared=0;
  outer:for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++){ if(arena[y][x]===0) continue outer; }
    const row=arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    linesCleared++; y++;
  }
  if(linesCleared>0){
    const points=[0,40,100,300,1200];
    score+=points[linesCleared];
    scoreDisplay.textContent='Score: '+score;
  }
}

function spawn(){
  current=next;
  next=randomPiece();
  current.pos.x=Math.floor((COLS-current.matrix[0].length)/2);
  current.pos.y=0;
  if(collide(arena,current.matrix,current.pos)){
    running=false;
    gameOverDisplay.style.display='block';
  }
}

function startGame(){
  running=true;
  current=randomPiece();
  next=randomPiece();
  score=0;
  scoreDisplay.textContent='Score: 0';
  gameOverDisplay.style.display='none';
  arena=createMatrix(COLS,ROWS);
  startBtn.style.display='none';
  update();
}

startBtn.addEventListener('click',startGame);
replayBtn.addEventListener('click',startGame);

window.addEventListener('keydown',event=>{
  if(!running) return;
  switch(event.key){
    case 'ArrowLeft': playerMove(-1); break;
    case 'ArrowRight': playerMove(1); break;
    case 'ArrowDown': drop(); break;
    case 'ArrowUp': playerRotate(1); break;
    case 'p': case 'P': paused=!paused; break;
    case ' ': event.preventDefault(); hardDrop(); break;
  }
});

document.getElementById('leftBtn').addEventListener('click',()=>playerMove(-1));
document.getElementById('rightBtn').addEventListener('click',()=>playerMove(1));
document.getElementById('downBtn').addEventListener('click',()=>drop());
document.getElementById('rotateBtn').addEventListener('click',()=>playerRotate(1));
document.getElementById('dropBtn').addEventListener('click',()=>hardDrop());
document.getElementById('pauseBtn').addEventListener('click',()=>paused=!paused);
</script>
</body>
</html>
